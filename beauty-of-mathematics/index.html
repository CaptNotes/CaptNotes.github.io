<!DOCTYPE html>
<html lang="zh">
  <head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="renderer" content="webkit" />
  <meta
    name="viewport"
    content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"
  />
  <title>
    《数学之美》摘要与心得 |  机长梦话
  </title>
  
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">
 
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">
 
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="机长梦话" type="application/atom+xml">
</head>


  <body id="bodyx">
    <div class="hd posts">
  <a href="/index.html"
    ><i class="fa fa-reply replay-btn" aria-hidden="true"></i
  ></a>
  <div class="post-title">
    <p>《数学之美》摘要与心得</p>
    <hr />
  </div>
  <div class="post-content"><blockquote>
<p>注：【】部分为笔者心得，非原文摘抄。</p>
</blockquote>
<ul>
<li>假定文本中的每个词$W_i$和前面$N-1$个词有关，而与更前面的词无关，这样当前词$W_i$的概率只取决于当前$N-1$个词$P(W_{i-N+1},W_{i-N+2},…,W_{i-1})$。因此$P(W_iW_1,W_2,…,W_{i-1})&#x3D;P(W_iW_{i-N+1},W_{i-N+2},…,W_{i-1})$称为$N-1$阶马尔科夫假设，对应的语言模型称为 N 元模型（N-Gram Model）。</li>
<li>在实际中应用最多的$N&#x3D;3$的三元模型。</li>
<li>N 元模型的大小（或者说空间复杂度）几乎是 N 的指数函数，即$O(V^{N-1})$。当 N 从 1 到 2，再从 2 到 3 时，模型的效果上升显著。而当模型从 3 到 4 时，效果的提升就不是很显著了，而资源的耗费却增加得非常快。</li>
<li>Google 的罗塞塔翻译系统和语音搜索系统，使用的是四元模型。</li>
<li>马尔科夫假设的局限性：在自然语言中，上下文之间的相关性可能跨度非常大。</li>
<li>对于没有看见的事件，不能认为它发生的概率就是零，（应该）从概率的总量（Probability Mass）中，分配一个很小的比例给这些没有看见的事件。</li>
<li>在实际的自然语言处理中，一般对出现次数超过某个阈值的词，频率不下调，只对出现次数低于这个阈值的词，频率才下调，下调得到的频率总和给未出现的词。<ul>
<li>阈值一般在 8-10 左右。</li>
</ul>
</li>
<li>如果训练语料和模型应用的领域相脱节，那么模型的效果往往会大打折扣。</li>
<li>在训练数据和应用数据一致并且训练量足够大的情况下，训练语料的噪音高低也会对模型的效果产生一定的影响。</li>
<li>马尔科夫假设：随机过程中各个状态$S_t$的概率分布，只与它的前一个状态$S_{t-1}$有关，即$P(S_tS_1,S_2,S_3,…,S_{t-1})&#x3D;P(S_tS_{t-1})$。<ul>
<li>符合这个假设的随机过程则称为马尔科夫过程，也称为马尔科夫链。</li>
</ul>
</li>
<li>隐含马尔科夫模型是马尔科夫链的一个扩展：任一时刻 t 的状态$S_t$是不可见的。观察者没法通过观察得到一个状态序列$S_1,S_2,S_3,…,S_T$来推测转移概率等参数。隐含马尔科夫模型在每个时刻 t 会输出一个符号$O_t$，而且$O_t$跟$S_t$相关且仅与$S_t$相关。这个被称为独立输出假设。</li>
<li>从前一个状态$S_{t-1}$进入当前状态$S_t$的概率$P(S_tS_{t-1})$称为转移概率（Transition Probability），状态$S_t$产生相应输出符号$O_t$的概率$P(O_tS_t)$称为生成概率（Generation Probability）。</li>
<li>数据是人工标注的，称为有监督的训练方法（Supervised Training），前提是需要大量人工标注的数据。</li>
<li>信息熵（Entropy）一般用符号$H$表示，单位是比特。</li>
<li>对于任意一个随机变量$X$，它的熵定义如下： $H(X)&#x3D;-\sum_{x \in X}P(x)logP(x)$</li>
<li>变量的不确定性越大，熵也就越大，要把它搞清楚，所需信息量也就越大。</li>
<li>几乎所有的自然语言处理、信息与信号处理的应用都是一个消除不确定性的过程。</li>
<li>信息的作用在于消除不确定性。</li>
<li>两个事件相关性的量化度量，就是在了解了其中一个$Y$的前提下，对消除另一个$X$不确定性所提供的信息量。互信息是一个去只在$0$到$min(H(X), H(Y))$之间的函数： $I(X;Y)&#x3D;H(X)-H(XY)$</li>
<li>互信息被广泛用于度量一些语言现象的相关性。</li>
<li>一个人要想在自己的领域做到世界一流，他的周围必须有非常多的一流人物。</li>
<li>技术分为术和道两种，具体的做事方法是术，做事的原理和原则是道。追求术的人一辈子工作很辛苦。</li>
<li>对于一个特定的查询，搜索结果的排名取决于两组信息：关于网页的质量信息，以及这个查询与每个网页的相关性信息。</li>
<li>PageRank 的核心思想：如果一个网页被很多其它网页所链接，说明它受到普遍的承认和信赖，那么它的排名就高。</li>
<li>给定一个查询，有关网页的综合排名大致由相关性和网页排名的乘积决定。</li>
<li>采用动态规划可以大大降低最短路径的计算复杂度。</li>
<li>语音识别解码器基本上是基于有限状态机的原理。</li>
<li>有限状态传感器（Finite State Transducer）的特殊性在于，有限状态机中的每个状态由输入和输出符号定义。</li>
<li>在语音识别中，每个被识别的句子都可以用一个 WFST（加权的有限状态传感器，Weighted Finite State Transducer）来表示，其中概率最大的那条路径就是这个句子的识别结果。</li>
<li>在计算机科学领域，一个好的算法应该向 AK-47 那样：简单、有效、可靠性好而且容易读懂（或者说易操作），而不应该是故弄玄虚。</li>
<li>在工程上，简单实用的方法最好。</li>
<li>先帮助用户解决 80%的问题，再慢慢解决剩下的 20%问题。</li>
<li>相比利用文本特征向量余弦的距离自底向上的分类方法，奇异值分解的优点是能较快地得到结果，因为它不需要一次次地迭代。但是用这种方法得到的分类结果略显粗糙，因此，它适合处理超大规模文本的粗分类。在实际应用中，可以先进行奇异值分解，得到粗分类结果，再利用计算向量余弦的方法，进行几次迭代，得到比较精确的结果。</li>
<li>加密函数不应该通过几个自变量和函数值就能推出函数本身。</li>
<li>从广义上讲，只要噪音不是完全随机并且前后有相关性，就可以检测到并且消除。</li>
<li>最大熵原理指出，对一个随机事件的概率分布进行预测时，我们的预测应当满足全部已知的条件，而对未知的情况不要做任何主观假设。</li>
<li>香农第一定律：对于一个信息，任何编码的长度都不小于它的信息熵。</li>
<li>把各种特征综合在一起最好的办法是采用最大熵模型。</li>
<li>好办法在形式上应该是简单的。</li>
<li>贝叶斯网络：每一个状态只跟与其直接相连的状态有关，而跟与它间接相连的状态没有直接关系。</li>
<li>由于每条弧都有一个可信度（即权重），贝叶斯网络也被称作信念网络（Belief Networks）。</li>
<li>贝叶斯网络不受马尔科夫链的链状结构约束，因此可以更准确地描述事件之间的关联性。</li>
<li>条件随机场是无向图，而贝叶斯网络是有向图。</li>
<li>扩频传输（Spread-Spectrum Transimission）和固定频率的传输相比，有三点优势：<ol>
<li>抗干扰能力极强；</li>
<li>信号很难被截获（能量非常低）；</li>
<li>利用带宽更充分。</li>
</ol>
</li>
<li>频分多址是对频率进行切分，每一路通信使用一个不同的频率。相邻频率会互相干扰，因此每个信道要有足够的带宽。</li>
<li>时分多址是将同一频带按时间分成很多份，每个人的（语音）通信数据在压缩后只占用这个频带传输的$1\over N$时间，这样同一个频带可以被多个人同时使用。</li>
<li>码分多址是指接收者在接到不同信号时，通过密码过滤掉自己无法解码的信号，留下和自己密码对应的信号即可。</li>
<li>训练最大熵模型的 IIS 方法（Improved Iterative Scaling，改进的迭代尺度法）可以直接用于训练逻辑回归函数的参数。</li>
<li>分治算法的基本原理是：将一个复杂的问题，分成若干个简单的子问题进行解决。然后，对子问题的结果进行合并，得到原有问题的解。</li>
<li>人工神经网络是一种特殊的有向图，其特殊性可以概括为：<ol>
<li>所有节点都是分层的，每一层节点可以通过有向弧指向上一层节点，但是同一层节点之间没有弧互相连接，而且每一个节点不能越过一层连接到上上层的节点上。理论上，人工神经网络的层数可以是任意的。只是在实际应用中一般不会有人设计超过 5 层的网络，因为网络的层数越多，计算就越复杂；</li>
<li>每一条弧上有一个值（称为权重或者权值），根据这些值，可以算出它们所指节点的值。</li>
</ol>
</li>
<li>人工神经网络擅长模式分类。</li>
<li>人工神经网络节点（即神经元）的取值是用一个非线性函数计算出来的，这个函数被称为神经元函数。</li>
<li>在人工神经网络中，规定神经元函数只能对输入变量线性组合后的结果进行一次非线性变换。</li>
<li>没有数据支持的决策常常不准确，而且个别成功案例的影响在人们心中会被放大，而风险则被缩小。</li>
<li>如果一个散户投资人能真正做到“用数据说话”，只需奉行一条投资决策，那就是买指数基金。</li>
<li>统计样本数量不充分，则统计数字毫无意义。</li>
<li>除了要求数据量必须足够多，统计还要求采样的数据具有代表性。</li>
<li>在搜索用到的诸多种数据中，最重要的数据有两类，即网页本身的数据和用户点击的数据。</li>
<li>大数据更重要的在于它的多维度和完备性，有了这两点才能将原本看似无关的事件联系起来，恢复出对事物全方位完整的描述。</li>
<li>只有当一些随机事件的组合一同出现了很多次以后，才能得到有意义的统计规律。</li>
<li>无论在什么领域，从事什么样的工作，谁懂得数据的重要性，谁会在工作中善用数据，就更有可能获得成功。</li>
<li>如果两个计算机算法在大$O$概念下相同，只相差一个常数，我们则认为它们的计算复杂度相同。</li>
<li>如果一个算法的计算量不超过 N 的多项式函数（Polynomial Function），那么称这个算法是多项式函数复杂度的。如果一个问题存在一个多项式复杂度的算法，这个问题称为 P 问题。这类问题被认为是计算机可以“有效”解决的。</li>
<li>如果一个问题，我们能够在多项式复杂度的时间里证实一个答案的正确与否，则不论目前这个问题是否能找到多项式复杂度的算法，都称这个问题为 NP 问题。</li>
<li>P 问题是 NP 问题的一个特殊的子集。</li>
<li>NPC（NP-Complete，NP 完备）问题是 NP 问题中最难的问题，因为如果任何一个 NPC 问题找到了多项式算法，那么所有的 NP 问题都可以用这个算法解决了，也即$NP&#x3D;P$。</li>
<li>NP-Hard 问题：计算复杂度至少是 NP-Complete 甚至更大的问题。</li>
<li>数学在计算机科学中的一个重要作用，就是找到计算复杂度尽可能低的解。同时，对于那些 NP-Complete 或者 NP-Hard 的问题，找到近似解。</li>
</ul>
</div>
</div>
 <div class="footer" id="footer">
  <p>
     © 2023
    <a class="flink" href="/">机长梦话</a>
    <label class="el-switch el-switch-green el-switch-sm">
      <input type="checkbox" id="update_style" />
      <label for="update_style"></label>
    </label>
  </p>
</div>
<input type="hidden" id="web_style" value="black" />

<script src="/libs/jquery.min.js"></script>
 
<script src="/libs/highlight/highlight.pack.js"></script>


<script src="/js/js.js"></script>
 
<script src="/js/dark-mode-toggle.js"></script>


<script>
  function detectColorScheme() {
    var theme = "light"; //default

    // get last used theme from local cache
    if (localStorage.getItem("theme")) {
      if (localStorage.getItem("theme") === "dark") {
        theme = "dark";
      }
    } else if (!window.matchMedia) {
      // matchMedia not supported
      return false;
    } else if (window.matchMedia("(prefers-color-scheme: dark)").matches) {
      // OS has set Dark Mode
      theme = "dark";
    }

    // set detected theme
    if (theme === "dark") {
      setThemeDark();
    } else {
      setThemeLight();
    }
  }

  const toggleTheme = document.querySelector(
    'input#theme-switch[type="checkbox"]'
  );

  function setThemeDark() {
    localStorage.setItem("theme", "dark");
    document.documentElement.setAttribute("data-theme", "dark");
    toggleTheme.checked = true;
  }
  function setThemeLight() {
    localStorage.setItem("theme", "light");
    document.documentElement.setAttribute("data-theme", "light");
    toggleTheme.checked = false;
  }

  // Listener for theme change by toggle
  toggleTheme.addEventListener(
    "change",
    function (e) {
      if (e.target.checked) {
        setThemeDark();
      } else {
        setThemeLight();
      }
    },
    false
  );

  // Listener for theme change by OS
  var toggleOS = window.matchMedia("(prefers-color-scheme: dark)");
  toggleOS.addEventListener("change", function (e) {
    if (e.matches) {
      setThemeDark();
    } else {
      setThemeLight();
    }
  });

  // call theme detection
  detectColorScheme();
</script>
<style type="text/css">
  .v * {
    color: #698fca;
  }

  .v .vlist .vcard .vhead .vsys {
    color: #15202b;
  }

  .v .vlist .vcard .vh .vmeta .vat {
    color: #638fd5;
  }

  .v .vlist .vcard .vhead .vnick {
    color: #6ba1ff;
  }

  .v a {
    color: #8696b1;
  }

  .v .vlist .vcard .vhead .vnick:hover {
    color: #669bfc;
  }
</style>

  </body>
</html>
